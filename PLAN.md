# Haskell開発環境 構築プラン

このドキュメントは、GitHub Codespaces上でHaskellを用いた競技プログラミング環境を構築するための作業計画を記述します。

## 1. 大目標

- GitHub Codespacesを利用して、AtCoderの2025年言語アップデート（GHC 9.8.4）に準拠したHaskell開発環境を構築し、`ac-library-hs`などのライブラリを利用可能にする。

## 2. これまでの経緯と課題の変遷

この環境構築は当初の想定より著しく難航した。将来のメンテナンスのため、失敗の経緯とそこから得られた知見を全て記録する。

### 2.1.【失敗】アプローチ1: Cabalベースでの環境構築

- **当初の計画:** AtCoder公式のGistで公開されている`cabal`ベースのセットアップを参考に、コンテナ内にライブラリをインストールし、`cabal run` や `cabal repl` での開発を目指した。
- **発生した問題:**
    1.  `cabal repl` で `ac-library-hs` などのライブラリが正しく認識されなかった。
    2.  上記はプロジェクト構成（`.cabal`ファイル）を調整することで解決したが、次に`cabal build`で生成した実行ファイルが標準出力に何も表示しない、という深刻な問題に直面した。
    3.  GHCやCabalのバージョン、コンテナ環境に深く依存する問題と推測されたが、原因の特定と解決が困難であった。
- **結論:** `cabal`による実行時の問題解決を断念し、より実績のある`stack`ベースのアプローチへ移行することを決定。

### 2.2.【失敗】アプローチ2: Stackグローバル環境の構築

- **計画:** `stack`をインストールし、`system-ghc: true`を設定して`ghcup`で導入したGHCを利用させつつ、`stack install`や`extra-deps`を用いて全ユーザーが暗黙的に利用できるグローバルなライブラリ環境の構築を目指した。
- **発生した問題（試行錯誤の連鎖）:**
    1.  **`stack config`コマンドのエラー:** `stack config set resolver --global` のようなコマンドが、`stack`のバージョンによって挙動が異なり、ビルドに失敗した。
    2.  **`stack install`の挙動誤解:** `stack install <packages...>` が、ローカルにプロジェクトがないと判断するとエラーになる問題に直面した。
    3.  **Dockerfileの構文・権限エラー:** 上記を回避するために複雑な`RUN`命令やビルドスクリプトを導入したが、`Dockerfile`の`RUN`命令のシェル解釈（`source`が使えない）、ヒアドキュメントの構文エラー、`COPY`命令のファイル所有権（`chmod`が失敗する）など、私のDocker知識不足による初歩的なミスを連発し、ビルド失敗を繰り返した。
    4.  **【根本原因】StackがシステムGHCを無視する:**
        - 上記の失敗を乗り越え、ようやくビルドが通った後も、`stack exec ghc -- --version` を実行すると、`ghcup`で入れたGHC `9.8.4`ではなく、Stackが独自にダウンロードしたGHC `9.10.3`を使い始めることが判明した。
        - これは、`~/.stack/config.yaml`に`system-ghc: true`を設定するだけでは、`stack`がカレントディレクトリに`stack.yaml`を見つけられない場合にフォールバックする「暗黙のグローバルプロジェクト」の挙動を制御するには不十分であったためである。
- **結論:** グローバルな環境を構築し、個々の`.hs`ファイルを独立して扱うという**アプローチ自体が、Stackのプロジェクトベースの設計思想と相性が悪く、不安定である**と判断。このアプローチを完全に破棄する。

## 3. 新しいアプローチと解決の見込み（先行調査済）

これまでの失敗とユーザーからの提案を踏まえ、**Devcontainer Featureを活用し、`hs`ディレクトリを単一のStackプロジェクトとして管理する**という、全く新しいアプローチに方針を転換する。

- **先行調査の結果:**
    1.  **GHC/Stackバージョンの実現性:** `ghcr.io/devcontainers-extra/features/haskell`というFeatureが存在し、オプションで`ghcVersion` (`9.8.4`を指定可) や`cabalVersion`を指定できる。また、`installStackGHCupHook: true` というオプション（デフォルトで有効）により、**StackがghcupでインストールしたGHCを確実に利用するようになる**ことが判明。これにより、これまで直面した最大の問題が解決できる。
    2.  **ライブラリの整合性:** 上記でGHC 9.8.4の環境が確実に構築できるため、`hs/`ディレクトリに配置する`stack.yaml`の`extra-deps`にAtCoder公式のライブラリ群を指定することで、依存関係の解決は可能である。これは`cabal`の公式設定で実績がある組み合わせであり、`stack`でも再現できる見込みが非常に高い。

- **結論:** この新アプローチは、これまでの失敗要因（Dockerfileの自作、ツールの挙動の不確実性）を排除し、ツールの標準的な使い方に沿った、最も確実で安定した方法であると判断。

## 4. 新・作業計画

- [x] **ステップ1: 環境のクリーンアップ**
    - [x] これまでの試行錯誤で作成した`.devcontainer/Dockerfile`および`.devcontainer/build-haskell-env.sh`を削除する。

- [x] **ステップ2: `devcontainer.json`の作成**
    - [x] `.devcontainer/devcontainer.json`を新規に作成する。
    - [x] `image`には`mcr.microsoft.com/devcontainers/base:ubuntu`などを指定。
    - [x] `features`ブロックを追加し、`ghcr.io/devcontainers-extra/features/haskell:2`を指定する。
    - [x] Featureのオプションで、`ghcVersion`を`"9.8.4"`、`cabalVersion`を`"3.14.2.0"`に設定する。`installStackGHCupHook`が`true`であることを確認する。

- [x] **ステップ3: Haskell Stackプロジェクトの作成**
    - [x] `hs/`ディレクトリ直下に`stack.yaml`を作成する。
        - `resolver`には、GHC 9.8.4に対応する`lts`が無いため、`ghc-9.8.4`のようなカスタム設定を行う。
        - `system-ghc: true`を指定する。
        - `packages: ['.']`などを指定する。
        - `extra-deps`に、AtCoder公式Gistから取得したライブラリのリストをバージョン付きで全て記述する。
    - [x] `hs/`ディレクトリ直下に`package.yaml`を作成する。
        - `name: atcoder-haskell-env`のような名前を付ける。
        - `dependencies`セクションに、`extra-deps`に記述したライブラリ名をリストする。
        - `library`セクションを定義し、全てのモジュールを`exposed-modules`に追加するか、あるいはダミーのライブラリとして構成する。これにより、`stack ghci`で全てのライブラリがスコープに入るようにする。

- [x] **ステップ4: ビルドと動作確認**
    - [x] コンテナをリビルドする。
    - [x] `hs/`ディレクトリに移動し、`stack build`を実行して、全ての依存関係がエラーなくビルドされることを確認する。
        - **Note:** `hmatrix` がCライブラリ (`blas`, `lapack`, `glpk`, `gsl`) に依存しており、ビルドに失敗した。`apt-get install` で `libblas-dev`, `liblapack-dev`, `libglpk-dev`, `libgsl-dev` をコンテナにインストールすることで解決した。この変更は `devcontainer.json` に反映する必要がある。
    - [x] `stack ghci`を起動し、ライブラリが利用可能であることを確認する。
        - **確認内容:** REPL上で `import AtCoder.` と入力し、Tab補完が効くこと。また、`AtCoder.Math.powMod` が実行できることを確認。
        - **結果:** ライブラリのインストールとGHCiによるロードは正常に行われていることを確認。
    - [x] テスト用のファイル (`hs/_trial/a/Main.hs`) をビルド・実行し、正常に動作することを確認する。
        - **ここまでの試行錯誤のまとめ:**
            - `stack build` や `stack exec runghc` でビルドを試みたが、`Variable not in scope` エラーが解決しなかった。
            - `package.yaml`の構成を単純化するなど、あらゆる手を尽くしたが、`stack`が`executable`の依存関係を正しく解決できない問題が解消されなかった。
        - **結論:** `stack`でのビルドを断念する。

- [x] **ステップ5: Cabal環境での基本的なビルド・実行パイプラインの確立**
    - **方針:** ビルドツールを`stack`から`cabal`に切り替える。
    - **懸念点:** 過去（ステップ2.1参照）に`cabal`でビルドした実行ファイルが正常に動作しない問題があった。
    - **成功の見込み:** 当時は手動でGHC/Cabalをインストールしていたが、現在はDevcontainer Featureにより、よりクリーンでバージョンの明確な環境が構築されているため、過去の問題は再発しない可能性が高い。
    - **これまでの試行錯誤のまとめ:**
        - `stack`関連ファイル(`stack.yaml`, `package.yaml`)を削除し、`cabal.project`と`atcoder-haskell-env.cabal`を作成した。
        - `ac-library-hs`に依存しないシンプルなコードで`cabal build`を試み、`Ambiguous type variable`エラーを型アノテーションで解決し、ビルドに成功した。
        - `cabal run` を実行し、期待通りの出力(`15`)を得られることを確認。これにより、`cabal`のビルド・実行パイプラインが正常に機能すること、及び過去の「実行しても何も出力されない」問題が解決したことを確認した。
        - **結論:** `cabal`環境での基本的なHaskellコードのビルド・実行パイプラインの確立が完了。
        - **Cライブラリの永続化:**
            - `hmatrix`等に必要なCライブラリ (`libblas-dev`, `liblapack-dev`, `libglpk-dev`, `libgsl-dev`) をDevcontainer Featureの`ghcr.io/devcontainers/features/apt`を使って`devcontainer.json`に恒久的にインストールする設定を追加する。

- [ ] **ステップ6: AtCoder言語アップデート2025準拠のHaskellライブラリ環境の厳密な検証**
    - **6.1. ライブラリバージョンの厳密な確認と照合:**
        - AtCoder言語アップデート2025でリストアップされたHaskellライブラリすべてについて、実際にインストールされているバージョンが指定のバージョンと一致しているかを一つずつ確認し、`PLAN.md`に記録する。
    - **6.2. 各ライブラリの動作検証 (最小コード):**
        - リストアップされた各ライブラリ（`ac-library-hs`は除く）について、その主要な機能が動作することを保証する最小限のテストコードを作成し、`cabal build`および`cabal run`で実行して確認する。
    - **6.3. `hs/.set` の更新と運用フローの確認:**
        - 実行方法が`stack`から`cabal`に変わったことを踏まえ、`hs/.set`ファイルを新しい実行コマンドに合わせて更新し、実際の競技プログラミングのコードと運用フローでの動作を確認する。
    - **6.4. クリーンな環境での再現性検証と`devcontainer.json`の更新:**
        - `hmatrix`等に必要なCライブラリ(`libblas-dev`, `liblapack-dev`, `libglpk-dev`, `libgsl-dev`)を`devcontainer.json`に恒久的に追加する設定を記述し、コンテナをリビルドして手作業なしで環境が再現できることを確認する。
    - **6.5. GitHub Codespacesでの動作確認:**
        - 最終的な環境がGitHub Codespaces上で問題なく動作することを確認する。
    - **6.6. ツール群のスリムアップ検討:**
        - 動作保証のために導入したジャッジサーバー相当のツール群が、本当に実行に必要なものか、スリムアップできる余地がないか検討する。
    - **6.7. `ac-library-hs`の対応 (別途):**
        - 上記が全て完了した後、`ac-library-hs`のビルド・実行に改めて挑戦する。
        - **(補足)** これまでの試行錯誤の中で、私の理解不足により`ac-library-hs`以外のライブラリの動作保証が完了したと早計に判断してしまった。今後は、ユーザーが求めている「AtCoder言語アップデート2025でリストアップされた各ライブラリが、リストアップされている通りのバージョンで利用できること」という厳密な基準に基づいて、`ac-library-hs`以外のすべてのライブラリの動作確認をステップ6.1〜6.6で徹底的に行う。

## 5. 作業方針と進行方法

- **コンテナ操作:**
    - 開発環境は `vsc-atcoder-***` という名称のDockerコンテナ内に構築されています。
    - 私はホストOSから `docker exec -w /workspaces/atcoder <コンテナ名 or ID> <コマンド>` を実行することで、コンテナ内でのビルド、テスト、ファイル操作を行います。
    - コンテナ上でコマンドを実行する際は、都度ユーザーに確認を求めます。
- **進捗管理:**
    - `PLAN.md` のタスクリストを随時更新し、作業の進捗を明確に記録します。
- **バージョン管理:**
    - 各ステップの作業が完了、または検証が一区切りつくたびに、変更内容をコミットし、リモートリポジトリにプッシュします。